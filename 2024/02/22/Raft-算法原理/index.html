<!DOCTYPE html>
<html lang="zh">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>Raft 算法原理</title>
<meta name="keywords" content="Raft 算法原理, HeXu">
<meta name="description" content="0.  前言面试可能会问到一些保证分布一致性的内容，前面因为Kafka顺带简单总结了一下ZooKeeper，今天学一下ETCD以及底层的Raft算法
1. 分布式共识算法1.1 如何提高大规模数据的读写性能？更好的机器属于纵向扩展，在系统设">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Raft 算法原理">
<meta property="og:description" content="0.  前言面试可能会问到一些保证分布一致性的内容，前面因为Kafka顺带简单总结了一下ZooKeeper，今天学一下ETCD以及底层的Raft算法
1. 分布式共识算法1.1 如何提高大规模数据的读写性能？更好的机器属于纵向扩展，在系统设">

<link rel="shortcut icon" href="/source/images/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://heexu976.github.io">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://heexu976.github.io">
        <h1 class="site-title">HeXu</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Raft 算法原理</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-02-22</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/%E9%9D%A2%E8%AF%95/">
              面试
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.  前言"></a>0.  前言</h1><p>面试可能会问到一些保证分布一致性的内容，前面因为Kafka顺带简单总结了一下ZooKeeper，今天学一下ETCD以及底层的Raft算法</p>
<h1 id="1-分布式共识算法"><a href="#1-分布式共识算法" class="headerlink" title="1. 分布式共识算法"></a>1. <strong>分布式共识算法</strong></h1><h2 id="1-1-如何提高大规模数据的读写性能？"><a href="#1-1-如何提高大规模数据的读写性能？" class="headerlink" title="1.1 如何提高大规模数据的读写性能？"></a>1.1 如何提高大规模数据的读写性能？</h2><h3 id="更好的机器"><a href="#更好的机器" class="headerlink" title="更好的机器"></a>更好的机器</h3><p>属于纵向扩展，在系统设计上没什么工作量，但压力来到了硬件设计这一侧. 机器的性能达到一定程度之后，想要更进一步的梯度会陡然提升.<br>这就好比一门满分 100 分的考试，从90分提升到 98分的难度可能大于从60分提升到90分的难度.</p>
<h3 id="更多的机器"><a href="#更多的机器" class="headerlink" title="更多的机器"></a>更多的机器</h3><p>属于横向扩展，理论上，在网络环境绝对理想化的情况下，这种方式可以做到上不封顶。</p>
<p>关于第（2）点需要补充说明的点是，在现实中并没有绝对理想的网络环境，集群节点数量也有一个合适的范围，一味地增加节点不加以约束，最终只会导致集群内部的网络请求行为反过来成为系统瓶颈点.</p>
<h2 id="1-2-分布式的优势和问题？"><a href="#1-2-分布式的优势和问题？" class="headerlink" title="1.2 分布式的优势和问题？"></a>1.2 分布式的优势和问题？</h2><p>首先，理清一个概念. 本文所谈及的分布式，更多指的是在同一模块内，为提高系统的吞吐量而采用的多节点的横向分布式，而非基于职责内聚性而进行模块划分并通过 rpc 交互串联整体的纵向分布式。</p>
<p>那么，这种横向分布式的优势主要体现在两点：</p>
<ol>
<li>数据备份：避免单点故障导致数据丢失或服务不可用；</li>
<li>负载均衡：多个节点共同分担总任务，那么理论上单个节点的任务强度与节点数量成反比.</li>
</ol>
<p>随之而来的是，横向分布式所带来的问题：</p>
<ol>
<li>如何保证不同节点之间，数据的一致性？（这里又可以进一步分为最终一致性和即时一次性）</li>
<li>如何保证分布式系统的秩序？（能正常提供服务，不出现脑裂、崩溃、耗时过长等问题）</li>
</ol>
<p>以上问题的根本原因在于网络的不确定性。</p>
<p>单节点的优势在于，单机的内存和磁盘读写操作都是很稳定的，要么成功，要么失败，则耗时很短.</p>
<p>而分布式引入了网络交互的流程，网络请求的耗时远远慢于单机操作，且网络请求可能存在丢失、超时、乱序等异常情况，这些情形都需要被妥善处理，从而导致系统整体复杂度的上升.</p>
<h2 id="1-3-CAP-理论"><a href="#1-3-CAP-理论" class="headerlink" title="1.3 CAP 理论"></a>1.3 CAP 理论</h2><p>下面聊聊经典的分布式系统理论：<code>CAP 理论（Consistency-Availability-Partition tolerance Theory）.</code></p>
<h3 id="C：Consitency，一致性"><a href="#C：Consitency，一致性" class="headerlink" title="C：Consitency，一致性"></a>C：Consitency，一致性</h3><p>该项强调数据的正确性. 具体而言，每次读操作，要么读到最新，要么读失败. 这要求整个分布式系统像是一个不可拆分的整体，写操作作用于集群像作用于单机一样，具有广义的“原子性”.</p>
<h3 id="A：Availability，可用性"><a href="#A：Availability，可用性" class="headerlink" title="A：Availability，可用性"></a>A：Availability，可用性</h3><p>该项站在使用者的角度，强调使用服务的体验.客户端的请求能够得到响应，不发生错误，也不能出现过长的等待时间.</p>
<h3 id="P：Partition-tolerance，分区容错性"><a href="#P：Partition-tolerance，分区容错性" class="headerlink" title="P：Partition tolerance，分区容错性"></a>P：Partition tolerance，分区容错性</h3><p>分区容错性强调的是，在网络环境不可靠的背景下，整个系统仍然是正常运作的，不至于出现系统崩溃或者秩序混乱的局面.</p>
<p>CAP 理论强调的是，一个系统中，C、A、P 三项性质至多只能满足其二，即每个系统依据其架构设计会具有 CP、AP 或者 CA 的倾向性.</p>
<p>首先，对于单机系统，其无须考虑 P，因此可以保证 CA 的满足;</p>
<p>其次，对于分布式系统而言, P 是必须得到保证的，否则这就违背了“分布式”的语义. 那么分布式系统会分为两种流派：</p>
<ol>
<li><strong>CP</strong>：强调系统数据的正确性，但由于建立保证不同节点间保证数据严格一致的机制，可能会牺牲系统的可用性.</li>
<li><strong>AP</strong>：强调系统的可用性，那就必须在数据一致性上做出妥协退让.</li>
</ol>
<p>分布式系统中，C 和 A 之间的矛盾正是在于网络环境的不稳定，下面对这两项所涉及的一些问题进一步展开介绍.</p>
<h2 id="1-4-C-的问题"><a href="#1-4-C-的问题" class="headerlink" title="1.4 C 的问题"></a>1.4 C 的问题</h2><h3 id="即时一致性问题"><a href="#即时一致性问题" class="headerlink" title="即时一致性问题"></a>即时一致性问题</h3><p>试想一个场景：</p>
<ol>
<li>当前集群的服务端有 master 和 follower 两个节点.</li>
<li>客户端写请求打到了 master，写入 x &#x3D; 3 这一项内容；</li>
<li>紧接着，客户端读请求打到了 follower，查询 x &#x3D; 3 的值.</li>
</ol>
<p>那么在第（3）步中所取得的 x 的值会是多少呢？答案是不确定的. 因为这取决于 master 和 follower 之间数据同步的机制.</p>
<p>倘若，为了满足更快响应客户端的诉求，服务端采用了异步完成数据同步任务的机制，那么客户端的读请求就可能在 follower 同步到 set x &#x3D; 3 这一项任务之前就打到 follower，此时会取到 x 的老数据或者 x 不存在的响应，总之，读到的数据和客户端期待的结果产生了差距.</p>
<p>以上，就是分布式系统中的即时一致性问题.</p>
<h3 id="顺序一致性问题"><a href="#顺序一致性问题" class="headerlink" title="顺序一致性问题"></a>顺序一致性问题</h3><p>现在请试想另一种场景：</p>
<ol>
<li>客户端依次向 master 发送了 set x &#x3D; 3、set x &#x3D; 4 的两笔请求；</li>
<li>master 在本机依次完成了两笔写操作，于是状态机中记录的结果为 x &#x3D; 4；</li>
<li>同时，master 异步开启将请求同步到 follower 的任务，任务发出的顺序也是 ① set x &#x3D; 3 ② set x &#x3D; 4；</li>
<li>由于网络问题，第 ① 笔请求出了点状况，导致第 ② 笔请求后发先至，第 ① 笔请求随后而至；</li>
<li>于是 follower 先执行 ② set x &#x3D; 4，后执行 ① set x &#x3D; 3，最终 follower 状态机内的结果为 x &#x3D; 3.</li>
</ol>
<p>这个问题相比场景（1）就更严重了，因为 follower 中已经记录了错误的数据，接下来不论何时面对客户端的读请求都会返回这个错误的结果. 这种情况下，我们就称分布式系统的最终一致性也遭到了破坏.</p>
<h2 id="1-5-A-的问题"><a href="#1-5-A-的问题" class="headerlink" title="1.5 A 的问题"></a>1.5 A 的问题</h2><p>为避免出现 1.4 小节涉及的问题，一种简单粗暴的方式是<strong>写操作 + 数据同步串行化</strong>，大致流程拆解如下：</p>
<ol>
<li>set x &#x3D; 3 的写请求到达 master；</li>
<li>master 将 x &#x3D; 3 写入本机状态机；</li>
<li>master 将 set x &#x3D; 3 同步到所有 follower；</li>
<li>当 master 接收到所有 follower 同步成功的响应，确保数据在整个请求均同步完成后，才给客户端 ack；</li>
<li>客户端无论向集群中哪个节点发起读请求，都保证能拿到最新的数据.</li>
</ol>
<p>这种流程与 1.4 小节的核心区别在于，数据同步任务不再是异步执行，而是与写请求串行化执行. 这种方式保证了在数据未同步完成前，客户端会因为未拿到 ack 而陷入阻塞，不会发起读请求.</p>
<p>这种串行处理的方式能够保证数据的强一致性，但是会存在哪些问题呢？</p>
<ol>
<li>倘若集群中某个 follower 出现宕机, master 同步数据时会因为未集齐所有 follower 的响应, 而无法给客户端 ack，这样一个节点的问题就会被放大到导致整个系统不可用；</li>
<li>倘若某个 follower 的网络环境或者本机环境出现问题，它给出同步数据响应的时间出乎意料的长，那么整个系统的响应效率都会被其拖垮，这就是所谓的木桶效应.</li>
</ol>
<h2 id="1-6-基于木桶效应面对-CAP"><a href="#1-6-基于木桶效应面对-CAP" class="headerlink" title="1.6 基于木桶效应面对 CAP"></a>1.6 基于木桶效应面对 CAP</h2><p>评价一个系统时，评价的标准不光体现在它的高光方面，更重要的是需要权衡它的下限. 这就类似于木桶效应，一个木桶能乘多少水，只取决于它最短的那块木板.</p>
<p>再举一个程序员们耳熟而详的例子，这就好比是我们在刷 leetcode 时需要设计一个数据结构，哪怕它有 M-1 个方法都是 O(1) 时间复杂度，只要唯独有 1 个方法是 O(N) 的时间复杂度，我们就只能说这是一个线性复杂度的数据结构.</p>
<p>那么此时的优化方案是什么呢？基于合理的设计思路，倘若能够将 O(N) 的这次存在性能抖动的任务进行负载均衡，通过巧妙数据结构设计，将这部分复杂度分摊到其他 M - 1 个方法中，使得</p>
<p>M 个方法的复杂度都变成 O(logN). 此时尽管 M-1 个方法复杂度由 O(1) 提高到了 O(logN)，但是数据结构的最低复杂度也从 O(N) 下降到了 O(logN). 这就是质变，这就能称得上是一个优越的改进.</p>
<p>这一思路之于 CAP 理论也同样适用. 强调 C 则舍弃了 A，突出 A 则违背了 C，这样必然导致对方成为了木桶效应中对系统最不利的那一块短板，显得无比眨扎眼.</p>
<p>实际上，C 和 A 并非站在绝对意义的对立面，其间还是存在可以调和取舍的空间. 这就好比是一道由黑逐渐过渡转白的连续光谱，除了黑白分明的两端之外，期间其实存在一段过渡的灰色空间，根据位置的不同，有的离黑色近些，颜色就深一些，有的离白色近些，颜色就淡些.</p>
<p>从这个角度出发，我们要做的是在光谱的灰色区域中找到一个合适的位置，提高系统的整体下限. 而所有分布式共识算法，以及我们今天所介绍的主题 raft 协议所要做的正是这样一件事情.</p>
<h2 id="1-7-分布式一致性共识算法"><a href="#1-7-分布式一致性共识算法" class="headerlink" title="1.7 分布式一致性共识算法"></a>1.7 分布式一致性共识算法</h2><p>分布式一致性共识算法指的是在分布式系统中，使得所有节点对同一份数据的认知能够达成共识的算法.</p>
<p>可以看到，不论是命名还是概述，都在突出其实现目标在于 C，即数据一致性. 然而，在 1.5 小节中我们已谈及，倘若基于写请求 + 数据同步串行化的方式进行实施，实际上是可以满足强 C 的，但是对应的 A 就会破坏得支离破碎.</p>
<p>因此，分布式一致性共识算法，实际上是在基于各种精妙的算法机制，<strong>能够在尽可能少地牺牲 C 的基础之上，将 A 提升到尽可能高的水平.</strong></p>
<p>我们今天的主角 raft 算法扮演的正是这样一个角色.</p>
<p>在可用性 A 方面，raft 算法能保证当分布式系统中<strong>存在半数以上节点存活时，系统是稳定可用的</strong>，同时请求耗时取决于多数派的下限，而非所有节点的下限；</p>
<p>在一致性 C 方面，标准的 raft 算法能够保证数据满足<strong>最终一致性</strong>，同时在各种工程化的落地实现中，我们可以在 raft 算法的基础上稍加改进，即可保证数据的即时一致性，进一步做到强 C.</p>
<h1 id="2-raft-算法核心概念"><a href="#2-raft-算法核心概念" class="headerlink" title="2. raft 算法核心概念"></a>2. raft 算法核心概念</h1><h2 id="2-1-术语表"><a href="#2-1-术语表" class="headerlink" title="2.1 术语表"></a>2.1 术语表</h2><table>
<thead>
<tr>
<th align="center">中文术语</th>
<th align="center">英文术语</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">领导者</td>
<td align="center">leader</td>
<td align="center">节点的三种角色之一. 集群的首脑，负责发起”提议“、”提交“被多数派认可的决断.</td>
</tr>
<tr>
<td align="center">跟随者</td>
<td align="center">follower</td>
<td align="center">节点的三种角色之一. 需要对 leader 的 ”提议“ 、”提交“和 candidate 的 ”竞选“ 进行响应.</td>
</tr>
<tr>
<td align="center">候选人</td>
<td align="center">candidate</td>
<td align="center">节点的三种角色之一. 是一种处于竞选流程中的临时状态，根据多数派投票的结果会切为 leader 或 follower 的稳定态.</td>
</tr>
<tr>
<td align="center">最终一致性</td>
<td align="center">final consistency</td>
<td align="center">中强一致性. 对于写请求，服务端保证最终一定能提供出正确的结果，但需要同步时间. 同步期间，可能被读到不一致的老数据.</td>
</tr>
<tr>
<td align="center">即时一次性</td>
<td align="center">immediate consistency</td>
<td align="center">强一致性. 服务端要求做到写入立即可读.</td>
</tr>
<tr>
<td align="center">预写日志</td>
<td align="center">write ahead log</td>
<td align="center">记录写请求明细的日志.（单指 raft 算法下狭义的预写日志）</td>
</tr>
<tr>
<td align="center">状态机</td>
<td align="center">state machine</td>
<td align="center">节点内存储数据的介质.</td>
</tr>
<tr>
<td align="center">提议</td>
<td align="center">proposal</td>
<td align="center">两阶段提交的第一个阶段. 指的是 leader 向所有节点发起日志同步请求的过程.</td>
</tr>
<tr>
<td align="center">提交</td>
<td align="center">commit</td>
<td align="center">两阶段提交的第二个阶段. 指的是 leader 认可一笔写请求已经被系统采纳的动作.</td>
</tr>
<tr>
<td align="center">应用</td>
<td align="center">apply</td>
<td align="center">指的是将预写日志记录内记录的写操作应用到状态机的过程.</td>
</tr>
<tr>
<td align="center">任期</td>
<td align="center">term</td>
<td align="center">任期是用于标识 leader 更迭的概念. 每个任期内至多只允许有一个 leader.</td>
</tr>
<tr>
<td align="center">日志索引</td>
<td align="center">index</td>
<td align="center">日志在预写日志数组中的位置.</td>
</tr>
<tr>
<td align="center">脑裂</td>
<td align="center">brain split</td>
<td align="center">同一任期内，集群出现两个 leader，导致秩序崩盘.</td>
</tr>
</tbody></table>
<h2 id="2-2-多数派原则"><a href="#2-2-多数派原则" class="headerlink" title="2.2 多数派原则"></a>2.2 多数派原则</h2><p>多数派，指的是一个群体的数量达到总数的一半以上.</p>
<p>多数派原则指的是，系统的决断无需全员参与,多数派达成的共识即可视为整个系统的答复.</p>
<p>以集群存在 5 个节点为例，多数派则需要集齐 3 个及 3 个以上节点，至多可以允许 2 个节点存在开小差背离主流的情况. 同理，倘若集群 6 个节点，则多数派需要集齐 4 个及 4 个以上节点，因此同样至多允许 2 个节点开小差. 综上，这是奉行多数派原则的集群通常将节点个数设置为奇数的原因之一.</p>
<p>多数派原则将会贯穿 raft 算法的始终，接下来不论是数据的同步，还是领导者的选举，只需要达到多数派的认可，就可即时采纳结果，同时处于拒绝态或者未响应态的少数派在随后感知到该决断已经被集群多数派认同后，最终也会执行采纳.</p>
<p>多数派原则是提高分布式系统可用性 A 的关键. 对于整个系统而言，执行一项操作要求全员共同响应以实现强 C 的保证是过于苛刻的，因为我们无法保证所有节点都能健康运作，这种底线思维是研发人员所必须具备的素养. 但是倘若退而求其次，只要多数派达成共识即可正常决断和响应，这样下限就提高很多了. 由全员响应进化为多数派共识，这将把一种底线思维下的随机性问题进化为一个数学期望问题.</p>
<p>多数派原则大大提升了 A 的分数，那么接下来的讨论重点就在于，raft 算法如何在多数派这一框架下，达成 C 的要求.</p>
<h2 id="2-3-一主多从、读写分离"><a href="#2-3-一主多从、读写分离" class="headerlink" title="2.3 一主多从、读写分离"></a>2.3 一主多从、读写分离</h2><p>接下来补充 raft 协议的第二、三个设定.</p>
<h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><p>raft 算法下系统中的节点分为领导者 leader 和跟随者 follower 两类角色.</p>
<p>leader拥有更广阔的视野，需要总览全局，领导一些日常事务的推进；</p>
<p>follower 职责相对简单但同样重要，因为这是一个基于多数派原则运作的民众团体，所有角色只要拧成一股绳，聚成了多数派，就能代表整个系统进行决断，甚至包括推翻 leader.</p>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>读操作可以由集群的任意节点提供服务；</p>
<p>写操作统一需要由 leader 收口处理，并向 follower 同步. 倘若 follower 率先收到了来自客户端的写请求，也需要转发给 leader 进行处理.</p>
<p>这种读写分离的机制，通过读操作的负载均衡提高了系统整体的吞吐量，也通过写操作的统一收口降低了共识算法的复杂度，但与此同时也衍生出两个问题：</p>
<ol>
<li><strong>(follower滞后问题)</strong> 读操作可由任意节点提供服务，那么倘若一个存在数据状态滞后的 follower 提供了服务，那么客户端就可能读到老数据. 因此到此为止，raft 只能保证到数据的最终一致性，而无法满足即时一致性. 在工程落地中，也针对读操作的即时一致性提出了改进方案，具体可见本文 4.2 小节；</li>
<li><strong>（leader失效问题）</strong> 集群一主多从，纵览全局. 倘若 leader 出了问题，群龙无首，系统岂不是会分崩离析吗？针对这个问题，raft 建立了一套完善的领导者选举机制，保证在 leader 不可用时会有替补席的 follower 挺身而出，改朝换代成为新的 leader，保证系统的正常运作，具体可见本文第 5 节.</li>
</ol>
<h2 id="2-4-状态机与预写日志"><a href="#2-4-状态机与预写日志" class="headerlink" title="2.4 状态机与预写日志"></a>2.4 状态机与预写日志</h2><p>状态机 （state machine）是节点实际存储数据的容器,<strong>写请求的最后一步是将结果写入状态机</strong>，而读请求也需要从状态机中获取数据进行响应.</p>
<p>预写日志（write ahead log，简称 wal）是通过日志的方式记录下每一笔写请求的明细（例如 set x &#x3D; 3 这样一笔记录），使得变更历史有迹可循. 在 raft 算法中，写请求会先组织成预写日志的形式添加到日志数组中，当一个日志（写请求）达到集群多数派的认可后，才能够被提交，将变更应用到状态机当中.</p>
<p><strong>（预写日志的作用 ：解决顺序一致性的问题）</strong><br>下面思考一个问题，为什么需要设计预写日志这一道流程，而不是直接将写请求应用到状态机呢？这样是否徒然增加了系统的复杂度？</p>
<p>预写日志的设计正是共识算法的精妙之处，其目的是为了解决 1.4 小节所提及的顺序一致性的问题.</p>
<p>预写日志由一个数组承载，为一段时间内的多笔写请求提供了一个缓存区；同时，每笔预写日志是一笔写请求的抽象，通过其记录的明细，使得我们可以对写请求的内容进行比较. 这样的机制之下，我们只要保证预写日志数组中，被准许应用到状态机的部分每笔预写日志的内容都完全相同，这样就能解决写请求乱序的问题，从而达成数据的最终一致性.</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>两阶段提交可以分别从单机和系统的两个维度进行解读.</p>
<p>从单机层面，一笔写请求会分为添加到预写日志和应用到状态机两个步骤，这是对两阶段提交的一种体现；</p>
<p>在整个系统层面，两阶段提交的流程可拆解如下：</p>
<ol>
<li>leader 接收到来自客户端的一笔写请求；</li>
<li>leader 将写请求添加到本地的预写日志中，并向集群中其他节点广播同步这笔写请求. 这个过程可以称之为“提议”（proposal）；</li>
<li>集群中各节点接收到同步请求后，会一套检验机制判断是否能执行同步（添加到预写日志），校验机制这里不细述，留待 4.1 小节细说；</li>
<li>倘若集群总计半数以上的节点（包括 leader 自身）都将这笔请求添加预写日志，并给予了 leader 肯定的答复（ack），那么 leader 此时会“提交”这个请求，并给予客户端写请求已成功处理的响应；</li>
<li>其他节点在随后的时段中，会通过与 leader 的交互（心跳或其他同步数据的请求）感知到这个“提交”动作，最终也在预写日志中提交这笔请求；</li>
<li>被提交的预写日志具备了被应用到状态机的资格. 但应用的时机取决于实现方式，倘若只追求最终一致性，可以选择异步应用；倘若追求立即一致性，则会要求 leader 先应用到状态机，才能给予客户端 ack.</li>
</ol>
<p>上述流程中，第（2）步是提议阶段（proposal），第（4）步是提交阶段（commit），两者相加，构成了所谓的“两阶段提交”的流程.</p>
<p>回头思考，可以发现正是这种两阶段提交的方式，实现了与多数派原则的串联打通. 因为有第一阶段的 proposal，leader 获得了群访 follower 收集民意的机会，一旦多数派达成共识，可以立即提交请求，并响应客户端，这样请求的耗时只取决于多数派中的短板，而不取决于全员的短板，大大提高了可用性.</p>
<p>需要注意的是，所有被提交的请求，都视为已经被系统所采纳，需要受到“最终一致性”这个语义的保护. 那么为什么说一个请求只要被多数派认可（添加到预写日志），就能够具备最终一致性呢，这其实是需要通过领导者选举机制的保证，同时，这个问题的答案将在本文 7.6 小节中给出.</p>
<h2 id="2-6-领导者选举"><a href="#2-6-领导者选举" class="headerlink" title="2.6 领导者选举"></a>2.6 领导者选举</h2><p>leader 是写请求的入口，如果出了问题，会导致整个集群不可写.</p>
<p>raft 中建立了一套完整的选举机制，倘若 leader 挂了，会由 follower 补位成为新的 leader.</p>
<p>这里讨论两个问题：</p>
<ol>
<li><p><strong>follower 如何感应到 leader 挂了，从而主动进行补位？</strong></p>
<p> leader 需要定期向 follower 发送心跳，证明自己仍然健在. 与之对应的，follower 会建立一个心跳检测定时器，当超过指定时长未收到 leader 的心跳，则认为 leader 已死，会切换成候选人（candidate）发起竞选，尝试补位成为新的 leader.</p>
</li>
<li><p><strong>什么样的 follower 有资格补位成为 leader？</strong></p>
<p> follower 成为 candidate 后,会广播向所有节点拉票，当投赞同票的节点数（包括candidate 本身）达到多数派的时候，该 candidate 会胜任，成为新的 leader.</p>
<p> 此处，参与投票的选民在决定结果时会有一套固定的判断机制，这将呼应了 2.5 小节最后提及的多数派准则下最终一致性的保证机制这一问题. 判断机制详细内容将在本文 5.3 小节中作展开.</p>
</li>
</ol>
<h2 id="2-7-任期与日志索引"><a href="#2-7-任期与日志索引" class="headerlink" title="2.7 任期与日志索引"></a>2.7 任期与日志索引</h2><p>任期 term，就像是朝代，集群由一个 leader 切换到另一个 leader 的过程称之为“改朝换代”，此时对应的任期数会进行累加。</p>
<p>每当一个 candidate 发起一轮竞选时，会将当前 term 在旧任期的基础上加1，倘若胜任成为新的 leader，这就将成为自己的“国号”.</p>
<p>值得一提的是，不是每个 term 都有 leader，因为可能在 candidate 未胜出的前提下，term 又进一步进行了累加，从而实现朝代的跨越.</p>
<p>但能够保证的是，每个 term 至多只会有一个 leader，具体的证明过程可见本文 7.1 小节.</p>
<p>节点中的预写日志存放在一个数组中，每则日志在数组中的位置称之为索引 index.</p>
<p>于是，每一则预写日志会有两个核心的标识属性：</p>
<ol>
<li>term：标志了这则日志是哪个任期的 leader 在位时同步写入的；</li>
<li>index：标志了这则日志在预写日志数组的位置.</li>
</ol>
<p>通过 {term , index} 二元组可以组成一个全局唯一键，定位到一则日志，并且能够保证位于不同节点中日志，只要其 term 和 index 均相同，其内容一定完全一致. 这一项证明可见本文 7.2 小节.</p>
<p>至此，raft 算法的核心概念初步介绍完毕，第 2 节只是做了主流程的阐述，一些细节还留待后续内容进行补充完善. 下面第 3 节将以 raft 算法下节点的三种角色以及其切换流程作为主线，进一步展开 raft 选举机制的原理介绍.</p>
<h1 id="3-raft-算法下节点的角色流转"><a href="#3-raft-算法下节点的角色流转" class="headerlink" title="3 raft 算法下节点的角色流转"></a>3 raft 算法下节点的角色流转</h1>
        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#0-%E5%89%8D%E8%A8%80"><span class="top-box-text">0.  前言</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95"><span class="top-box-text">1. 分布式共识算法</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-1-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%BB%E5%86%99%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="top-box-text">1.1 如何提高大规模数据的读写性能？</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%9C%BA%E5%99%A8"><span class="top-box-text">更好的机器</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%9C%BA%E5%99%A8"><span class="top-box-text">更多的机器</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-2-%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="top-box-text">1.2 分布式的优势和问题？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-3-CAP-%E7%90%86%E8%AE%BA"><span class="top-box-text">1.3 CAP 理论</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#C%EF%BC%9AConsitency%EF%BC%8C%E4%B8%80%E8%87%B4%E6%80%A7"><span class="top-box-text">C：Consitency，一致性</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#A%EF%BC%9AAvailability%EF%BC%8C%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="top-box-text">A：Availability，可用性</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#P%EF%BC%9APartition-tolerance%EF%BC%8C%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7"><span class="top-box-text">P：Partition tolerance，分区容错性</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-4-C-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="top-box-text">1.4 C 的问题</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8D%B3%E6%97%B6%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="top-box-text">即时一致性问题</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="top-box-text">顺序一致性问题</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-5-A-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="top-box-text">1.5 A 的问题</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-6-%E5%9F%BA%E4%BA%8E%E6%9C%A8%E6%A1%B6%E6%95%88%E5%BA%94%E9%9D%A2%E5%AF%B9-CAP"><span class="top-box-text">1.6 基于木桶效应面对 CAP</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-7-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95"><span class="top-box-text">1.7 分布式一致性共识算法</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#2-raft-%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="top-box-text">2. raft 算法核心概念</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-1-%E6%9C%AF%E8%AF%AD%E8%A1%A8"><span class="top-box-text">2.1 术语表</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-2-%E5%A4%9A%E6%95%B0%E6%B4%BE%E5%8E%9F%E5%88%99"><span class="top-box-text">2.2 多数派原则</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-3-%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="top-box-text">2.3 一主多从、读写分离</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E"><span class="top-box-text">一主多从</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="top-box-text">读写分离</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-4-%E7%8A%B6%E6%80%81%E6%9C%BA%E4%B8%8E%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97"><span class="top-box-text">2.4 状态机与预写日志</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="top-box-text">两阶段提交</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-6-%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE"><span class="top-box-text">2.6 领导者选举</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-7-%E4%BB%BB%E6%9C%9F%E4%B8%8E%E6%97%A5%E5%BF%97%E7%B4%A2%E5%BC%95"><span class="top-box-text">2.7 任期与日志索引</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#3-raft-%E7%AE%97%E6%B3%95%E4%B8%8B%E8%8A%82%E7%82%B9%E7%9A%84%E8%A7%92%E8%89%B2%E6%B5%81%E8%BD%AC"><span class="top-box-text">3 raft 算法下节点的角色流转</span></a></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/02/14/Golang-%E7%9A%84%E9%80%89%E9%A1%B9%E6%A8%A1%E5%BC%8F%EF%BC%88Option-%E6%A8%A1%E5%BC%8F%EF%BC%89/">
          <h3 class="post-title">
            下一篇：Golang 的选项模式（Option 模式）
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/heexu976" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>



    <script async src="https://hm.baidu.com/hm.js?b4e7880ffb5b09f08a8941a64e7d79f4"></script>




  </body>
</html>

