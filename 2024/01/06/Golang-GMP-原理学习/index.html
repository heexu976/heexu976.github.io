<!DOCTYPE html>
<html lang="zh">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>Golang GMP 原理学习</title>
<meta name="keywords" content="Golang GMP 原理学习, HeXu">
<meta name="description" content="前言通过写博客的方法学习一下 Golang 的各种机制和特性，顺便锻炼锻炼表达能力，这个是第一篇，先尽量让自己看懂吧。
1. 概念1.1 线程线程已经很熟悉了，面试时八股文必考点之一，下面再简单总结一下：
通常所说的线程，一般是指内核级别的">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Golang GMP 原理学习">
<meta property="og:description" content="前言通过写博客的方法学习一下 Golang 的各种机制和特性，顺便锻炼锻炼表达能力，这个是第一篇，先尽量让自己看懂吧。
1. 概念1.1 线程线程已经很熟悉了，面试时八股文必考点之一，下面再简单总结一下：
通常所说的线程，一般是指内核级别的">

<link rel="shortcut icon" href="/source/images/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://heexu976.github.io">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://heexu976.github.io">
        <h1 class="site-title">HeXu</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Golang GMP 原理学习</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-01-06</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Golang/">
              Golang
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过写博客的方法学习一下 Golang 的各种机制和特性，顺便锻炼锻炼表达能力，这个是第一篇，先尽量让自己看懂吧。</p>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><p>线程已经很熟悉了，面试时八股文必考点之一，下面再简单总结一下：</p>
<p>通常所说的线程，一般是指内核级别的线程，面试时常常用来和进程来进行比较，下面是线程和进程之间的区别：</p>
<ul>
<li><p><strong>线程</strong>：</p>
<ul>
<li>线程是进程内的轻量级执行单位，<strong>是操作系统最小调度单元</strong>；</li>
<li>一个进程中可以存在多个线程。</li>
<li>线程共享相同的内存和资源。</li>
<li>线程在进程内创建，共享地址空间。</li>
<li><strong>创建、销毁、调度交由内核完成，CPU 需完成用户态与内核态间的切换；</strong></li>
<li>创建和切换线程的开销较小。</li>
<li>线程可以在多个处理器核心上并行运行。</li>
<li>一个线程崩溃可能导致整个进程终止。</li>
<li>线程用于并发编程和提高应用程序响应性。</li>
</ul>
</li>
<li><p><strong>进程</strong>：</p>
<ul>
<li>进程是正在执行的程序的实例。</li>
<li>每个进程都是独立的，与其他进程隔离。</li>
<li>进程拥有自己的内存和资源，需要使用进程间通信机制。</li>
<li>进程由操作系统创建，拥有自己的地址空间。</li>
<li>进程由操作系统的进程调度器调度和执行。</li>
<li>创建和切换进程的开销较大。</li>
<li>进程可以在多个处理器或多台机器上并行运行。</li>
<li>一个进程崩溃不会影响其他进程。</li>
<li>进程用于运行独立任务、资源隔离和系统稳定性。</li>
</ul>
</li>
</ul>
<h3 id="1-2-协程"><a href="#1-2-协程" class="headerlink" title="1.2 协程"></a>1.2 协程</h3><p>协程也比较好理解，相比于<strong>线程诞生于内核，协程是诞生于用户空间的</strong>，但是诞生于用户态的协程们需要收到内核线程的管理，也就是存在一个映射关系 N：1，创建、销毁、调度在用户态完成，对内核透明，所以协程更轻。</p>
<p>但是也会带来问题：从属同一个内核级线程，无法并行，一个协程的阻塞，会导致从属于这个线程的所有协程阻塞。</p>
<h3 id="1-3-Goroutine"><a href="#1-3-Goroutine" class="headerlink" title="1.3 Goroutine"></a>1.3 Goroutine</h3><p>基于以上问题，Golang 提出了 Goroutine，简单来说就是经过“优化”的协程，特点如下：</p>
<ol>
<li>用户态协程和内核级线程之间的映射关系为 M：N；</li>
<li>创建、调度、销毁在用户态完成，对内核透明，非常轻量；</li>
<li>利用多个线程，所以可以并行；</li>
<li>栈空间大小是灵活可变的。</li>
</ol>
<p><a class="simple-lightbox" href="/../images/Golang-GMP-%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/go-gmp-goroutine.png"><img   src="/images/loading.svg" data-src="/../images/Golang-GMP-%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/go-gmp-goroutine.png"  alt="goroutine" lazyload></a></p>
<h2 id="2-GMP-模型"><a href="#2-GMP-模型" class="headerlink" title="2. GMP 模型"></a>2. GMP 模型</h2><p><strong>GMP &#x3D; Goroutine + Machine + Processor</strong>，下面进行单独介绍</p>
<h3 id="2-1-G"><a href="#2-1-G" class="headerlink" title="2.1 G"></a>2.1 G</h3><ol>
<li>G就是Goroutine，是Go中经过优化的协程；</li>
<li>G拥有自己的运行栈、状态以及执行的任务函数（代码中的 go func）；</li>
<li>G需要绑定到P才能运行，从G的角度看，P就是G的CPU。</li>
</ol>
<h3 id="2-2-P"><a href="#2-2-P" class="headerlink" title="2.2 P"></a>2.2 P</h3><ol>
<li>P就是Processor，是Golang的调度器；</li>
<li>P是GMP的中枢，起到了一个承上启下的作用，来将底层的M和用户态的G进行了有机结；</li>
<li>对于G而言，P是CPU，G被P调度了，G才能执行；</li>
<li>对于M而言，P是M的代理，P隐藏了复杂的调度M的细节；</li>
<li>P的数量决定了G的最大并发数量，用户通过GOMAXPEROCS进行设定（不要超过CPU的核数）</li>
</ol>
<h3 id="2-3-M"><a href="#2-3-M" class="headerlink" title="2.3 M"></a>2.3 M</h3><ol>
<li>M即machine，是 golang 中对线程的抽象；</li>
<li>M不直接执行G，而是先和P进行绑定，由P来进行代理；</li>
<li>由于有P的存在，M无需和G绑死，也无需记录M的生命周期，G在全生命周期中可以实现跨M执行。</li>
</ol>
<h3 id="2-4-GMP"><a href="#2-4-GMP" class="headerlink" title="2.4 GMP"></a>2.4 GMP</h3><p>对三部分进行一个整合，进行一下总结：</p>
<ol>
<li>M是线程抽象；G是Goroutine；P是承上启下的调度器；</li>
<li>M在调度G之前，先和P绑定；</li>
<li>全局有多个M和多个P，但是同时并行的G的最大数量等于P的数量；</li>
<li>G的存放的队列有三类：a.P的本地队列 b.全局队列 c.wait队列（IO阻塞就绪态goroutine队列）；</li>
<li>当M需要调度G的时候，优先从P本地队列取，再从全局队列取，最后从wait队列取；这样的好处是取P本地队列的时候，近似于无锁化，减少全局锁竞争；</li>
<li>为了防止不同的P之间工作压力茶语过大，设立了<strong>work-stealing</strong>机制，本地队列为空的P可以从其他P本地队列中偷取一半的G到自身队列中；</li>
</ol>
<h2 id="源码数据结构"><a href="#源码数据结构" class="headerlink" title="源码数据结构"></a>源码数据结构</h2><p>GMP 数据结构定义在 runtime&#x2F;runtime2.go 文件中。只摘取核心字段</p>
<h2 id="3-1-G"><a href="#3-1-G" class="headerlink" title="3.1 G"></a>3.1 G</h2><pre class="line-numbers language-none"><code class="language-none">type g struct &#123;
    &#x2F;&#x2F; ...
    m         *m   &#x2F;&#x2F;负责执行当前G的M   
    &#x2F;&#x2F; ...
    sched     gobuf &#x2F;&#x2F;调度器
    &#x2F;&#x2F; ...
&#125;


type gobuf struct &#123;
    sp   uintptr &#x2F;&#x2F; CPU rsp 寄存器的值，指向函数调用栈的栈顶
    pc   uintptr &#x2F;&#x2F; CPU rip 寄存器的值，指向下一条指令的地址
    ret  uintptr &#x2F;&#x2F; 保存系统调用的返回值
    bp   uintptr &#x2F;&#x2F; CPU rbp 寄存器的值，存储函数栈帧的起始位置
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>G的生命周期：</p>
<pre class="line-numbers language-none"><code class="language-none">const(
  _Gidle &#x3D; itoa &#x2F;&#x2F; 0 协程开始创建的状态
  _Grunnable    &#x2F;&#x2F; 1 协程在待执行队列，等待被执行
  _Grunning     &#x2F;&#x2F; 2 协程正在执行，一个P中一个G处于此状态
  _Gsyscall     &#x2F;&#x2F; 3 协程正在执行系统调用
  _Gwaiting     &#x2F;&#x2F; 4 协程处于挂起态，需要等待被唤醒。gc，channel通信是会经常进入这种状态
  _Gdead        &#x2F;&#x2F; 6 协程刚初始化完成或者已经被销毁
  _Gcopystack   &#x2F;&#x2F; 8 协程正在栈扩容中
  _Gpreempted   &#x2F;&#x2F; 9 协程被抢占
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-2-M"><a href="#3-2-M" class="headerlink" title="3.2 M"></a>3.2 M</h3><pre class="line-numbers language-none"><code class="language-none">type m struct &#123;
    g0      *g     &#x2F;&#x2F; 一种特殊的调度协程，不会执行用户函数，执行g的调度，和m数量1:1
    &#x2F;&#x2F; ...
    tls           [tlsSlots]uintptr &#x2F;&#x2F; thread-local storage 线程本地存储内容，存储的内容只对本线程可见
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-3-P"><a href="#3-3-P" class="headerlink" title="3.3 P"></a>3.3 P</h3><pre class="line-numbers language-none"><code class="language-none">type p struct &#123;
    &#x2F;&#x2F; ...
    runqhead uint32        &#x2F;&#x2F; 队列头部
    runqtail uint32        &#x2F;&#x2F; 队列尾部
    runq     [256]guintptr &#x2F;&#x2F; 本地 goroutine 队列，最大长度 256
    runnext guintptr       &#x2F;&#x2F; 下一个可执行的 goroutine
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-schedt"><a href="#3-4-schedt" class="headerlink" title="3.4 schedt"></a>3.4 schedt</h3><p>schedt 是全局 goroutine 队列的封装</p>
<pre class="line-numbers language-none"><code class="language-none">type schedt struct &#123;
    &#x2F;&#x2F; ...
    lock mutex      &#x2F;&#x2F; 操作全剧队列的锁
    &#x2F;&#x2F; ...
    runq     gQueue &#x2F;&#x2F; 全剧队列
    runqsize int32  &#x2F;&#x2F; 队列容量
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h2><h3 id="4-1-两种G的转换"><a href="#4-1-两种G的转换" class="headerlink" title="4.1 两种G的转换"></a>4.1 两种G的转换</h3><p>goroutine 有两大类：</p>
<ol>
<li>g0: 负责调度普通的g，执行固定的调度流程</li>
<li>g : 执行用户函数的普通g</li>
</ol>
<p>m通过p来调度执行的goroutine永远在普通g和g0之间切换，当g0找到可执行的g时，会调用**gogo()**，调度g执行用户定义的任务；当g需要主动让渡或者被动调度的时候会触发 **mcall()**，将执行权交回g0。</p>
<h3 id="4-2-调度类型"><a href="#4-2-调度类型" class="headerlink" title="4.2 调度类型"></a>4.2 调度类型</h3><p>通常，调度指的是由g0按照特定策略找到下一个可以执行的g的过程。本小节指的是调度器p实现从一个g切换到另外一个g。<br>本小结“调度”的集中类型：</p>
<ol>
<li>主动调度</li>
<li>被动调度</li>
<li>正常调度</li>
<li>抢占调度</li>
</ol>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%89%8D%E8%A8%80"><span class="top-box-text">前言</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="top-box-text">1. 概念</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#1-1-%E7%BA%BF%E7%A8%8B"><span class="top-box-text">1.1 线程</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#1-2-%E5%8D%8F%E7%A8%8B"><span class="top-box-text">1.2 协程</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#1-3-Goroutine"><span class="top-box-text">1.3 Goroutine</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-GMP-%E6%A8%A1%E5%9E%8B"><span class="top-box-text">2. GMP 模型</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-1-G"><span class="top-box-text">2.1 G</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-2-P"><span class="top-box-text">2.2 P</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-3-M"><span class="top-box-text">2.3 M</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-4-GMP"><span class="top-box-text">2.4 GMP</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%BA%90%E7%A0%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="top-box-text">源码数据结构</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#3-1-G"><span class="top-box-text">3.1 G</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-2-M"><span class="top-box-text">3.2 M</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-3-P"><span class="top-box-text">3.3 P</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-4-schedt"><span class="top-box-text">3.4 schedt</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="top-box-text">调度流程</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-1-%E4%B8%A4%E7%A7%8DG%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="top-box-text">4.1 两种G的转换</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-2-%E8%B0%83%E5%BA%A6%E7%B1%BB%E5%9E%8B"><span class="top-box-text">4.2 调度类型</span></a></li></ol></li></ol>
        </div>
          
      </div>
    </div>

    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/heexu976" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>



    <script async src="https://hm.baidu.com/hm.js?b4e7880ffb5b09f08a8941a64e7d79f4"></script>




  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>

