<!DOCTYPE html>
<html lang="zh">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>Golang 网络 IO 模型之 EPOLL</title>
<meta name="keywords" content="Golang 网络 IO 模型之 EPOLL, HeXu">
<meta name="description" content="0 前言本文大抵分为两部分：第一部分聊 epoll 的实现原理（第一、二章）；第二部分串联 Golang 底层 IO 模型实现链路（第三章），观察其中对 epoll 技术的应用.
1 IO 多路复用1.1 何为 IO 多路复用首先拆解多路复">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Golang 网络 IO 模型之 EPOLL">
<meta property="og:description" content="0 前言本文大抵分为两部分：第一部分聊 epoll 的实现原理（第一、二章）；第二部分串联 Golang 底层 IO 模型实现链路（第三章），观察其中对 epoll 技术的应用.
1 IO 多路复用1.1 何为 IO 多路复用首先拆解多路复">

<link rel="shortcut icon" href="/source/images/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://heexu976.github.io">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://heexu976.github.io">
        <h1 class="site-title">HeXu</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Golang 网络 IO 模型之 EPOLL</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-01-22</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Golang/">
              Golang
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><p>本文大抵分为两部分：第一部分聊 epoll 的实现原理（第一、二章）；第二部分串联 Golang 底层 IO 模型实现链路（第三章），观察其中对 epoll 技术的应用.</p>
<h1 id="1-IO-多路复用"><a href="#1-IO-多路复用" class="headerlink" title="1 IO 多路复用"></a>1 IO 多路复用</h1><h2 id="1-1-何为-IO-多路复用"><a href="#1-1-何为-IO-多路复用" class="headerlink" title="1.1 何为 IO 多路复用"></a>1.1 何为 IO 多路复用</h2><p>首先拆解多路复用一词：</p>
<ul>
<li>多路：存在多个待服务的对象</li>
<li>复用：只由一个执行单元提供服务</li>
</ul>
<p>串联上述要点，多路复用指的是，由<strong>一个执行单元</strong>，<strong>同时对多个对象提供服务</strong>，形成一对多的服务关系.</p>
<p>在 Linux 操作系统中，对 IO 多路复用的概念有着更加明确的定义：</p>
<ul>
<li><code>多路</code>：存在多个需要处理 <code>io event</code> 的 <code>fd</code>（Linux 中，一切皆文件，所有事务均可抽象为一个文件句柄 <code>file descriptor</code>，简称 <code>fd</code>）</li>
<li><code>复用</code>：复用一个 <code>loop thread</code> 同时为多个 <code>fd</code> 提供处理服务（线程 <code>thread</code> 是内核视角下的最小调度单位；多路复用通常为循环模型 <code>loop model</code>，因此称为 <code>loop thread</code>）</li>
</ul>
<h2 id="1-2-IO-多路复用的简单实现"><a href="#1-2-IO-多路复用的简单实现" class="headerlink" title="1.2 IO 多路复用的简单实现"></a>1.2 IO 多路复用的简单实现</h2><h3 id="1-阻塞-IO"><a href="#1-阻塞-IO" class="headerlink" title="1. 阻塞 IO"></a>1. 阻塞 IO</h3><p>下面通过一段伪代码，来尝试让 IO 多路复用这个概念看起来更加具体一些：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 多个待服务的 fd 
fds &#x3D; [fd1,fd2,fd3,...]
&#x2F;&#x2F; 遍历 fd 列表，末尾和首部相连，形成循环
i &#x3D; 0
for &#123;
    &#x2F;&#x2F; 获取本轮待处理的 fd
    fd &#x3D; fds[i]        
    &#x2F;&#x2F; 从 fd 中读数据
    data &#x3D; read(fd)  
    &#x2F;&#x2F; 处理数据 
    handle(data)             
    &#x2F;&#x2F; 推进遍历
    i++
    if i &#x3D;&#x3D; len(fds)&#123;
        i &#x3D; 0
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述搭了个架子，核心分为几步：</p>
<ul>
<li>定义了待处理的 fds 列表（多路）</li>
<li>循环遍历 fds 列表，每轮负责读一个 fd（复用）</li>
</ul>
<p>这是个乞丐版的 IO 多路复用模型看起来似乎有那么点意思了. 然而其本质上是一种阻塞 IO 模型 <strong>（Blocking IO，简称 BIO）</strong>. 事实上，上述实现存在一个致命的问题，那就是句柄 fd 默认的 io 操作是阻塞型的，因此倘若在读 fd1 的时候，io event 没到达，那么 loop thread 就会陷入阻塞，后续 fd2、fd3 哪怕有 io event 到达，也无法得到执行.</p>
<h3 id="2-非阻塞-IO"><a href="#2-非阻塞-IO" class="headerlink" title="2. 非阻塞 IO"></a>2. 非阻塞 IO</h3><p>基于 BIO 存在的问题，我们进行一轮改进，核心是将 read 操作由同步阻塞操作改为带有尝试性的<strong>非阻塞操作</strong>. 在读一个 fd 的时候，倘若 io event 已就绪就正常读取，否则就即时返回并抛出一个特定类型的错误，让 loop thread 能够正常执行下去，为其他 fd 提供服务.</p>
<pre class="line-numbers language-none"><code class="language-none"> fds &#x3D; [fd1,fd2,fd3,...]

&#x2F;&#x2F; 遍历 fd 列表，末尾和首部相连，形成循环
i &#x3D; 0
for &#123;
    &#x2F;&#x2F; 获取本轮待处理的 fd
    fd &#x3D; fds[i]        
    &#x2F;&#x2F; 尝试从 fd 中读数据，失败时不阻塞，而是抛出错误
    data,err &#x3D; tryRead(fd)  
    &#x2F;&#x2F; 读取数据成功，处理数据
    if err &#x3D;&#x3D; nil&#123;
        handle(data) 
    &#125; 
    &#x2F;&#x2F; 小睡一秒后再推进流程
    sleep(1 second)
    &#x2F;&#x2F; 推进遍历
    i++
    if i &#x3D;&#x3D; len(fds)&#123;
        i &#x3D; 0
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述伪代码核心步骤如下：</p>
<ul>
<li>定义了待处理的 fds 列表</li>
<li>遍历 fds 列表，每轮尝试从一个 fd 中读数据</li>
<li>倘若 io event 已就绪，则正常处理结果</li>
<li>倘若 io event 未就绪，只抛出错误，同样不阻塞流程</li>
<li>小睡一会儿，然后继续推进流程</li>
</ul>
<p>这里确实解决阻塞 IO 中的问题，其本质上是一种<strong>非阻塞 IO 模型（Nonblocking IO，简称 NIO</strong>）. 但这里仍然存在问题，就是每轮处理之间的休眠时间. 倘若在休眠期间，fd 中有 io event 到达，就无法被正常处理，这同样是一种不好的体验.</p>
<h2 id="1-3-IO-多路复用的优雅实现"><a href="#1-3-IO-多路复用的优雅实现" class="headerlink" title="1.3 IO 多路复用的优雅实现"></a>1.3 IO 多路复用的优雅实现</h2><p>linux 内核提供了三种经典的多路复用技术：</p>
<blockquote>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
</blockquote>
<p><code>select</code> 最通用，但是相对粗糙；而 <code>epoll</code> 则最精致，在性能上也有着最优越的表现.</p>
<p><code>poll</code> 在 <code>select</code> 的基础之上做了改进，但治标不治本，优化得不够彻底. 我们核心还是来对比看看 <code>select</code> 和 <code>epoll</code> 之间的共性和差异：</p>
<h3 id="1-select"><a href="#1-select" class="headerlink" title="1. select"></a>1. select</h3><ul>
<li>一次可以处理多个 fd，体现多路. 但 fd 数量有限，最多 1024 个</li>
<li>loop thread 通过 select 将一组 fd 提交到内核做监听</li>
<li>当 fd 中无 io event 就绪时，loop thread 会陷入阻塞</li>
<li>每当这组 fd 中有 io event 到达时，内核会唤醒 loop thread</li>
<li>loop thread 无法精准感知到哪些 fd 就绪，需要遍历一轮 fd 列表，时间复杂度 O(N)</li>
<li>托付给内核的 fd 列表只具有一轮交互的时效. 新的轮次中，loop thread 需要重新将监听的 fd 列表再传递给内核一次</li>
</ul>
<h3 id="2-epoll"><a href="#2-epoll" class="headerlink" title="2. epoll"></a>2. epoll</h3><ul>
<li>每次处理的 fd 数量无上限</li>
<li>loop thread 通过 epoll_create 操作创建一个 epoll 池子</li>
<li>loop thread 通过 epoll_ctl 每次将一个待监听的 fd 添加到 epoll 池中</li>
<li>每当 fd 列表中有 fd 就绪事件到达时，会唤醒 loop thread. 同时内核会将处于就绪态的 fd 直接告知 loop thread，无需额外遍历</li>
</ul>
<p>综上所述，select 和 epoll 等多路复用操作利用了内核的能力，能在待监听 fd 中有 io event 到达时，将 loop thread 唤醒，避免无意义的主动轮询操作.</p>
<p>其中，epoll 相比于 select 的核心性能优势在于：</p>
<ul>
<li>loop thread 被唤醒时，能明确知道哪些 fd 需要处理，减少了一次额外遍历的操作，时间复杂度由 O(N) 优化到 O(1)；</li>
<li>epoll 通过将创建池子和添加 fd 两个操作解耦，实现了池中 fd 数据的复用，减少了用户态与内核态间的数据拷贝成本。</li>
</ul>
<h1 id="2-EventPoll-原理"><a href="#2-EventPoll-原理" class="headerlink" title="2 EventPoll 原理"></a>2 EventPoll 原理</h1><h2 id="2-1-核心原理"><a href="#2-1-核心原理" class="headerlink" title="2.1 核心原理"></a>2.1 核心原理</h2><p>epoll 又称 EventPoll，使用很简单，包含三个指令：</p>
<ul>
<li>epoll_create</li>
<li>epoll_ctl</li>
<li>epoll_wait</li>
</ul>
<h3 id="1-epoll-create"><a href="#1-epoll-create" class="headerlink" title="1. epoll_create"></a>1. epoll_create</h3><p>在内核开辟空间，创建一个 epoll 池子用于批量存储管理 fd，后续可以通过 epoll_ctl 往池子中增删改 fd.</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">epollcreate1</span><span class="token punctuation">(</span>flags <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token builtin">int32</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-epoll-ctl"><a href="#2-epoll-ctl" class="headerlink" title="2. epoll_ctl"></a>2. epoll_ctl</h3><p>在某个 <code>epoll</code> 池子中进行一个 fd 的增删改操作.</p>
<p>正是由于 <code>epoll</code> 中将 <code>epoll_ctl</code> 与 <code>epoll_create</code> 操作进行了解耦，才实现了对 <code>epoll_create</code> 时传递的 fd 数据的复用，<strong>减少了用户态和内核台之间对 fd 数据的重复传递</strong></p>
<p>此外，在 epoll_ctl 实现时，也需要通过 epollevent 设置好回调事件，当 fd 有指定事件到达时，会被添加到就绪队列中，最终将 loop thread 唤醒.</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">epollctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> op<span class="token punctuation">,</span> fd <span class="token builtin">int32</span><span class="token punctuation">,</span> ev <span class="token operator">*</span>epollevent<span class="token punctuation">)</span> <span class="token builtin">int32</span>


<span class="token keyword">type</span> epollevent <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    events <span class="token builtin">uint32</span>
    data   <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token comment">// unaligned uintptr</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-epoll-wait"><a href="#3-epoll-wait" class="headerlink" title="3. epoll_wait"></a>3. epoll_wait</h3><p>从对应 epoll 池子中获取就绪的 epollevent，从中可以关联到对应的 fd 和 loop thread 信息.</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">epollwait</span><span class="token punctuation">(</span>epfd <span class="token builtin">int32</span><span class="token punctuation">,</span> ev <span class="token operator">*</span>epollevent<span class="token punctuation">,</span> nev<span class="token punctuation">,</span> timeout <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token builtin">int32</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2-2-核心数据结构"><a href="#2-2-核心数据结构" class="headerlink" title="2.2 核心数据结构"></a>2.2 核心数据结构</h2><h3 id="1-epoll-池红黑树"><a href="#1-epoll-池红黑树" class="headerlink" title="1. epoll 池红黑树"></a>1. epoll 池红黑树</h3><p>一个 epoll 池子中管理的 fd 数量理论上上不封顶. 同时后续可能存在对 fd 的增删改操作，因此需要使用合适的数据结构加以管理，从而降低后续操作的时间复杂度.</p>
<p>linux 内核中，实现 <code>epoll</code> 池的数据结构采用的是红黑树（<code>Red-Black Tree</code>，一种自平衡二叉查找树，这里不作展开，感兴趣自行了解）实现，保证了所有增、删、改操作的平均时间复杂度维持在 <strong>O(logN)</strong> 的对数级水平.</p>
<h3 id="2-就绪时间队列"><a href="#2-就绪时间队列" class="headerlink" title="2. 就绪时间队列"></a>2. 就绪时间队列</h3><p>针对于 fd 的就绪 <code>io event</code>，由于通常数量有限，且每个事件都需要逐一处理，没有优先级之分，因此采用简单的<strong>双向链表</strong>实现即可.</p>
<h2 id="2-3-事件回调机制"><a href="#2-3-事件回调机制" class="headerlink" title="2.3 事件回调机制"></a>2.3 事件回调机制</h2><p>epoll <strong>高效的核心建立在精准的事件回调机制</strong>之上.</p>
<p>首先，通过内核感知到 io event 事件的动态，令 loop thread 在合适的时机阻塞，避免浪费 CPU；在合适的时机执行，及时处理 io event.</p>
<p>其次，在 io event 就绪时，会精准地将真正就绪的 fd 传递到 loop thread 手中，减少了一次无意义的遍历查询动作.</p>
<p>事件回调的注册是在调用 epoll_ctl 添加 fd 时，此时会提前设置好对这个 fd 关心的事件类型，当对应的 io event 真的发生时，内核会将该 fd 和对应的 loop thread 封装到 epollevent 中，添加到就绪队列 ready list 当中.</p>
<h1 id="3-Golang-网络-IO-源码走读"><a href="#3-Golang-网络-IO-源码走读" class="headerlink" title="3 Golang 网络 IO 源码走读"></a>3 Golang 网络 IO 源码走读</h1>
        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#0-%E5%89%8D%E8%A8%80"><span class="top-box-text">0 前言</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#1-IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="top-box-text">1 IO 多路复用</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-1-%E4%BD%95%E4%B8%BA-IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="top-box-text">1.1 何为 IO 多路复用</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-2-IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="top-box-text">1.2 IO 多路复用的简单实现</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#1-%E9%98%BB%E5%A1%9E-IO"><span class="top-box-text">1. 阻塞 IO</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-%E9%9D%9E%E9%98%BB%E5%A1%9E-IO"><span class="top-box-text">2. 非阻塞 IO</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-3-IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0"><span class="top-box-text">1.3 IO 多路复用的优雅实现</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#1-select"><span class="top-box-text">1. select</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-epoll"><span class="top-box-text">2. epoll</span></a></li></ol></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#2-EventPoll-%E5%8E%9F%E7%90%86"><span class="top-box-text">2 EventPoll 原理</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-1-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="top-box-text">2.1 核心原理</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#1-epoll-create"><span class="top-box-text">1. epoll_create</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-epoll-ctl"><span class="top-box-text">2. epoll_ctl</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-epoll-wait"><span class="top-box-text">3. epoll_wait</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-2-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="top-box-text">2.2 核心数据结构</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#1-epoll-%E6%B1%A0%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="top-box-text">1. epoll 池红黑树</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-%E5%B0%B1%E7%BB%AA%E6%97%B6%E9%97%B4%E9%98%9F%E5%88%97"><span class="top-box-text">2. 就绪时间队列</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-3-%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6"><span class="top-box-text">2.3 事件回调机制</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#3-Golang-%E7%BD%91%E7%BB%9C-IO-%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB"><span class="top-box-text">3 Golang 网络 IO 源码走读</span></a></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/01/22/Golang-HTTP-%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%9E%E7%8E%B0/">
          <h3 class="post-title">
            下一篇：Golang HTTP 标准库实现
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/heexu976" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>



    <script async src="https://hm.baidu.com/hm.js?b4e7880ffb5b09f08a8941a64e7d79f4"></script>




  </body>
</html>

